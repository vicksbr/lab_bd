Relatorio

1) conversar sobre, adicionar total todas com um comando analitico no SELECT * FROM (SUB QUERY) 
	http://docs.oracle.com/cd/B19306_01/server.102/b14223/analysis.htm#i1007516 Fillin  Gaps in Data


CREATE GLOBAL TEMPORARY TABLE tabela1
on commit preserve rows
AS
(SELECT * FROM (
  SELECT DISTINCT
  METODO.METODO_ENTREGA_ID,
  metodo.NOME,
  EXTRACT(MONTH FROM ven.DATA_VENDA) AS MES,
  SUM(VEN.FRETE) OVER (PARTITION BY metodo.NOME,EXTRACT(MONTH FROM ven.DATA_VENDA) ORDER BY metodo.METODO_ENTREGA_ID) SUB_MENOR_MES ,
  SUM(VEN.FRETE) OVER (PARTITION BY metodo.NOME,EXTRACT(YEAR FROM ven.DATA_VENDA) ORDER BY METODO.METODO_ENTREGA_ID) AS SUB_MENOR_ANO,
  SUM(VEN.FRETE) OVER (ORDER BY METODO.METODO_ENTREGA_ID) AS TOTAL_TODAS
  FROM VENDA ven INNER JOIN METODO_ENTREGA metodo ON VEN.METODO_ENTREGA_ID = METODO.METODO_ENTREGA_ID
  WHERE EXTRACT(YEAR FROM ven.DATA_VENDA) = 2011 AND VEN.SUBTOTAL < 1000 /* ano escolhido */ 
  ORDER BY metodo.NOME, MES
))

;

CREATE GLOBAL TEMPORARY TABLE tabela2
on commit preserve rows
AS 
  SELECT DISTINCT
  METODO.METODO_ENTREGA_ID,
  metodo.NOME,
  EXTRACT(MONTH FROM ven.DATA_VENDA) AS MES,
  SUM(VEN.FRETE) OVER (PARTITION BY metodo.NOME,EXTRACT(MONTH FROM ven.DATA_VENDA) ORDER BY metodo.METODO_ENTREGA_ID) SUB_MAIOR_MES ,
  SUM(VEN.FRETE) OVER (PARTITION BY metodo.NOME,EXTRACT(YEAR FROM ven.DATA_VENDA) ORDER BY METODO.METODO_ENTREGA_ID) AS SUB_MAIOR_ANO,
  SUM(VEN.FRETE) OVER (ORDER BY METODO.METODO_ENTREGA_ID) AS TOTAL_TODAS
  FROM VENDA ven INNER JOIN METODO_ENTREGA metodo ON VEN.METODO_ENTREGA_ID = METODO.METODO_ENTREGA_ID
  WHERE EXTRACT(YEAR FROM ven.DATA_VENDA) = 2011 AND VEN.SUBTOTAL > 1000 /* ano escolhido */ 
  ORDER BY metodo.NOME, MES
;

SELECT
        TABELA2.NOME, 
        TABELA2.MES, 
        TABELA1.SUB_MENOR_MES,
        TABELA1.SUB_MENOR_ANO,
        TABELA2.SUB_MAIOR_MES,
        TABELA2.SUB_MAIOR_ANO,
        TABELA2.TOTAL_TODAS
FROM
        tabela1 full join tabela2 on TABELA1.MES = TABELA2.MES
ORDER BY 
        NOME,MES
;

TRUNCATE TABLE tabela1;
TRUNCATE TABLE tabela2;
drop table tabela1;
drop table tabela2;

2) Parece perfeito

SELECT DISTINCT 
    EXTRACT(YEAR FROM ven.DATA_VENDA) AS ANO,
    COUNT(ven.CLIENTE_ID) OVER (PARTITION BY EXTRACT(YEAR FROM ven.DATA_VENDA) ORDER BY EXTRACT(YEAR FROM ven.DATA_VENDA)) AS QTD_COMPRA,
    SUM(ven.TOTAL_DEVIDO) OVER (PARTITION BY EXTRACT(YEAR FROM ven.DATA_VENDA) ORDER BY EXTRACT(YEAR FROM ven.DATA_VENDA)) AS SOMA_COMPRA  
 FROM 
    VENDA ven INNER JOIN CLIENTE cli ON VEN.CLIENTE_ID = CLI.CLIENTE_ID
WHERE 
    VEN.CLIENTE_ID = 13668;


3) parece perfeito

SELECT DISTINCT
  PAIS, 
  ESTADO,
  COUNT(ESTADO) OVER (PARTITION BY ESTADO ORDER BY PAIS,ESTADO) as TOTAL_CLIENTE_ESTADO,
  COUNT(PAIS) OVER (PARTITION BY PAIS ORDER BY PAIS) as TOTAL_CLIENTE_PAIS,
  COUNT(PAIS) OVER () as TOTAL_MUNDO
  FROM(
        SELECT DISTINCT 
            EST.PAIS     as PAIS,
            EST.NOME     as ESTADO, 
            VEN.CLIENTE_ID,
            VEN.VENDA_ID,
            VEN.ENDERECO_ENTREGA 
        FROM 
            VENDA ven 
            INNER JOIN CLIENTE cli ON VEN.CLIENTE_ID = CLI.CLIENTE_ID
            INNER JOIN ENDERECO ende ON VEN.ENDERECO_ENTREGA = ENDE.ENDERECO_ID
            INNER JOIN ESTADO est ON ENDE.ESTADO_ID = EST.ESTADO_ID
        ORDER BY PAIS,ESTADO
      )
ORDER BY PAIS,ESTADO
;




4) FALTA FAZER A média vendida entre os 2 dias anteriores e os 2 dias seguintes. Perguntar se é o que eu to pensadno

SELECT DISTINCT
  ANO,
  MES,
  DIA,
  COUNT(TOTAL_DEVIDO) OVER (PARTITION BY DIA ORDER BY DIA) as SOMA
FROM (
      SELECT DISTINCT 
          EXTRACT(YEAR FROM ven.DATA_VENDA) AS ANO,
          EXTRACT(MONTH FROM ven.DATA_VENDA) AS MES,
          EXTRACT(DAY FROM ven.DATA_VENDA) AS DIA,
          VENDA_ID,
          VEN.TOTAL_DEVIDO TOTAL_DEVIDO
      FROM
          VENDA ven
      WHERE 
          EXTRACT(MONTH FROM ven.DATA_VENDA) = 10
      ORDER BY 
          ANO,MES,DIA
      )
ORDER BY ANO,DIA
;


5)	– Para cada Subcategoria, o número de itens vendidos, total vendido,
	ranking da categoria e ranking geral (pelo total vendido);
	– Para cada Categoria, o número de itens vendidos, total vendido e
	ranking geral (pelo total vendido);


*falta o total vendido e os rankings da sub e cat (ja feito para os produtos)

SELECT DISTINCT
      MES,
      NOME,
      QTD_VEND,
      SUBCAT,
      SUBCAT_NOME,
      CATEGO,      
      DENSE_RANK() OVER (PARTITION BY SUBCAT,MES ORDER BY MES,QTD_VEND DESC) as RANKSUB,
      DENSE_RANK() OVER (PARTITION BY CATEGO,MES ORDER BY MES,QTD_VEND DESC,SUBCAT) as RANKCAT,
      DENSE_RANK() OVER (PARTITION BY MES ORDER BY MES,QTD_VEND DESC) RANK_GERAL,
      SUM(QTD_VEND) OVER (PARTITION BY SUBCAT,MES ORDER BY SUBCAT,MES) as TOTAL_SUBCAT,
      SUM(QTD_VEND) OVER (PARTITION BY CATEGO,MES ORDER BY CATEGO,MES) as TOTAL_CAT
      FROM (
        SELECT DISTINCT
          EXTRACT(MONTH FROM ven.DATA_VENDA) AS MES,
          vi.PRODUTO_ID,  
          pro.NOME as NOME,
          sub.SUBCATEGORIA_ID as SUBCAT,
          SUB.NOME as SUBCAT_NOME,
          sub.CATEGORIA CATEGO,
          COUNT(1) OVER (PARTITION BY vi.PRODUTO_ID,EXTRACT(MONTH FROM ven.DATA_VENDA) ORDER BY vi.PRODUTO_ID,EXTRACT(MONTH FROM ven.DATA_VENDA)) AS QTD_VEND,
          COUNT(1) OVER () AS QTD_TOTAL
        FROM 
          VENDA ven 
          INNER JOIN VENDA_ITEM vi ON ven.VENDA_ID = vi.VENDA_ID
          INNER JOIN PRODUTO pro ON vi.PRODUTO_ID = pro.PRODUTO_ID
          INNER JOIN SUBCATEGORIA sub ON pro.SUBCATEGORIA = sub.SUBCATEGORIA_ID
        WHERE 
          EXTRACT(YEAR FROM ven.DATA_VENDA) = 2013
        ORDER BY MES, QTD_VEND DESC
        )
ORDER BY MES,QTD_VEND DESC
;


6)

SELECT DISTINCT
  ANO,
  MES,
  SOMA_TOTAL_MES,
  LAG(SOMA_TOTAL_MES,1,0) OVER (ORDER BY MES) AS DIFF
FROM(
      SELECT DISTINCT
        ANO,
        MES,
        SUM(TOTAL_DEVIDO) over (PARTITION BY MES ORDER BY MES) as SOMA_TOTAL_MES        
      FROM( 
        SELECT 
          EXTRACT(YEAR FROM ven.DATA_VENDA) as ANO,
          EXTRACT(MONTH FROM ven.DATA_VENDA) as MES,
          ven.TOTAL_DEVIDO as TOTAL_DEVIDO
        FROM 
          VENDA ven 
        WHERE 
          EXTRACT(YEAR FROM ven.DATA_VENDA) = 2012
      )
      ORDER BY ANO,MES
      )
ORDER BY ANO,MES
;


/*teste*/

SELECT SUM(ven.TOTAL_DEVIDO) FROM VENDA ven 
WHERE EXTRACT(YEAR FROM ven.DATA_VENDA) = 2012 AND EXTRACT(MONTH FROM ven.DATA_VENDA) = 11;


7) Tem que somar os itens que formam o mesmo par mas foram comprados em ordem diferente e tem que ver esse lance do ranking porque ele sofre do 
mesmo problema. Talvez a solução seja fazer um union no começo  

SELECT 
  * 
FROM(
  SELECT DISTINCT
      prod1_id,
      nome1,
      cat1,
      prod2_id,
      nome2,
      cat2,
      Vezes,
      DENSE_RANK () OVER (ORDER BY VEZES DESC) as cat_rank,
      prod1_vezes,
      DENSE_RANK () OVER (ORDER BY prod1_vezes DESC) as prod1_rank,
      prod2_vezes,
      DENSE_RANK () OVER (ORDER BY prod2_vezes DESC) as prod2_rank
  FROM( 
    SELECT 
      prod1_id,
      nome1,
      cat1,
      prod2_id,
      nome2,
      cat2,
      COUNT(nome_concat) OVER (PARTITION BY nome_concat ORDER BY nome_concat) as Vezes,
      prod1_vezes,
      prod2_vezes
    FROM (
      SELECT 
        PROD1.PRODUTO_ID as prod1_id,
        PROD2.PRODUTO_ID as prod2_id,
        PROD1.NOME AS nome1,
        SUBCAT1.CATEGORIA AS cat1,
        PROD2.NOME AS nome2,
        SUBCAT2.CATEGORIA AS cat2,
        PROD1.NOME || PROD2.NOME as nome_concat,
        COUNT(1) OVER (PARTITION BY prod1.nome) as prod1_vezes,
        COUNT(1) OVER (PARTITION BY prod2.nome) as prod2_vezes
      FROM 
        VENDA_ITEM v1 INNER JOIN PRODUTO prod1 ON V1.PRODUTO_ID = PROD1.PRODUTO_ID INNER JOIN SUBCATEGORIA subcat1 ON PROD1.SUBCATEGORIA = SUBCAT1.SUBCATEGORIA_ID,
        VENDA_ITEM v2 INNER JOIN PRODUTO prod2 ON V2.PRODUTO_ID = PROD2.PRODUTO_ID INNER JOIN SUBCATEGORIA subcat2 ON PROD2.SUBCATEGORIA = SUBCAT2.SUBCATEGORIA_ID
      WHERE 
        v1.VENDA_ID = v2.VENDA_ID AND V1.VENDA_ITEM_ID <> V2.VENDA_ITEM_ID AND V1.VENDA_ITEM_ID < V2.VENDA_ITEM_ID
      )
  )
)
WHERE CAT_RANK < 10
ORDER BY nome1,cat_rank
;

/* 
SELECT 
  COUNT(1) 
FROM 
  VENDA_ITEM v1 INNER JOIN PRODUTO prod1 ON V1.PRODUTO_ID = PROD1.PRODUTO_ID INNER JOIN SUBCATEGORIA subcat1 ON PROD1.SUBCATEGORIA = SUBCAT1.SUBCATEGORIA_ID,
  VENDA_ITEM v2 INNER JOIN PRODUTO prod2 ON V2.PRODUTO_ID = PROD2.PRODUTO_ID INNER JOIN SUBCATEGORIA subcat2 ON PROD2.SUBCATEGORIA = SUBCAT2.SUBCATEGORIA_ID
WHERE 
  v1.VENDA_ID = v2.VENDA_ID AND 
  V1.VENDA_ITEM_ID <> V2.VENDA_ITEM_ID AND 
  V1.VENDA_ITEM_ID < V2.VENDA_ITEM_ID AND 
  PROD1.PRODUTO_ID = 870 AND
  PROD2.PRODUTO_ID = 871
;*/


8) Parece perfeito

SELECT DISTINCT
  EST.NOME as ESTADO,
  EXTRACT(MONTH FROM ve.DATA_VENDA) AS MES,
  SUM(ve.IMPOSTOS) over (PARTITION BY est.ESTADO_ID,EXTRACT(MONTH FROM ve.DATA_VENDA)) AS SOMA_MES_ESTADO,
  SUM(ve.IMPOSTOS) over (PARTITION BY est.ESTADO_ID) AS SOMA_MES_ANO,
  SUM(ve.IMPOSTOS) over (ORDER BY EXTRACT(MONTH FROM ve.DATA_VENDA)) AS SOMA_TOTAL_MES,
  SUM(ve.IMPOSTOS) over () AS SOMA_TOTAL_ANO
FROM 
  VENDA ve 
  INNER JOIN ENDERECO ende ON VE.ENDERECO_COBRANCA = ENDE.ENDERECO_ID
  INNER JOIN ESTADO est ON ENDE.ESTADO_ID = est.ESTADO_ID
WHERE EXTRACT(YEAR FROM ve.DATA_VENDA) = 2012
ORDER BY ESTADO,MES
;


9) PARECE PERFEITO

SELECT DISTINCT
  PAIS,
  ESTADO,
  ROUND((SOMA_ESTADO/SOMA_PAIS)*100,4) AS perc_est_pais,
  ROUND((SOMA_ESTADO/SOMA_MUNDO)*100,4) AS perc_est_mundo
FROM 
  (
  SELECT DISTINCT
    EST.PAIS AS PAIS,
    EST.NOME AS ESTADO,
    SUM(VE.TOTAL_DEVIDO) OVER (PARTITION BY EST.PAIS,EST.NOME) AS SOMA_ESTADO,
    SUM(VE.TOTAL_DEVIDO) OVER (PARTITION BY EST.PAIS) AS SOMA_PAIS,
    SUM(VE.TOTAL_DEVIDO) OVER () AS SOMA_MUNDO
  FROM 
    VENDA ve 
    INNER JOIN ENDERECO ende ON VE.ENDERECO_COBRANCA = ENDE.ENDERECO_ID
    INNER JOIN ESTADO est ON ENDE.ESTADO_ID = est.ESTADO_ID
  ORDER BY 
    EST.PAIS,EST.NOME
  )
ORDER BY PAIS,perc_est_mundo DESC
;